'number' + 3 + 3
/* результат 'number33'
   крок 1 - до типу даних string зі значенням 'number' додали тип даних number зі значенням 3 -> відбулося склеювання та результат набув тип string ('number3')
   крок 2 - до утворенного типу даних string зі значенням 'number3' додали тип даних number зі значенням 3 -> відбулося склеювання та результат набув тип string ('number33') */

null + 3
/* результат 3
   крок 1 - тип даних null неявно перетворився на number зі значенням 0
   крок 2 - відбулася дія додавання між двома типами даних number -> отримали результат арефметичної дії з типом даних number та значенням 3 */

5 && "qwerty"
/* результат 'qwerty'
   крок 1 - маємо вираз з логічним оператором І
   крок 2 - зліва маємо тип даних number, який при порівнянні логічним оператором повертає значення true
   крок 3 - зпарва маємо тип даних string, який при порівнянні логічним оператором повертає значення true
   крок 4 - при пикористанні логічного оператора І повертається останньє true виразу, тобто 'qwerty' */

    +'40' + +'2' + "hillel";
/* результат '42hillel'
   крок 1 - унарний плюс перетворює тип даних string зі значенням'40' на тип даниз number зі значенням 40 І
   крок 2 - унарний плюс перетворює тип даних string зі значенням '2' на тип даних number зі значенням 2
   крок 3 - відбувається арефметична дія додавання двох чисел, результатом є тип даних number зі значенням 42
   крок 4 - до типу даних number зі значенням 42 додається тип даних string зі значенням "hillel" -> 
            -> відбувається склеювання та результат набув тип string, тобто отримуємо '42hillel' */

'10' - 5 === 6;
/* результат false
   крок 1 - тип даних string зі значенням '10' неявно перетворилось на тип даних number зі значенням 10 
   крок 2 - відбулась арефметична опезація віднімання між двома типами даних number -> повернувся тип даних number зі значенням 5
   крок 3 - зліва маємо тип даних number зі значенням 5, зправа маємо тип даних number зі значенням 6
   крок 4 - маємо оператора строгої равності, який порівнює не тільки значення, а й типи операндів -> тут маємо однаковий тип, але різне значення(розмір)
   крок 5 - оператор строгої рівності повертає boolean значення, тобто в даному випадку false  */

true + false
/* результат 1
   крок 1 - зліва відбувається неявне перетворення даних з типу boolean зі значенням true до типу number зі значенням 1
   крок 2 - зправа відбувається неявне перетворення даних з типу boolean зі значенням false до типу number зі значенням 0
   крок 3 - відбувається арефметична дія додавання двох перетворених значень -> результат має типа даних number зі значенням 1  */

'4px' - 3
/* результат NaN
   крок 1 - зліва маємо тип даних string зі значенням '4px', яке не може бути перетворено у тип даних number, бо містить символи
   крок 2 - зправа маємо тип даних number зі значенням 3
   крок 3 - між такими даними не може відбутися дія віднімання, отже отримуємо результат NaN  */

'4' - 3
/* результат 1
   крок 1 - зліва маємо тип даних string зі значенням '4', яке неявно перетворюється на тип number зі значенням 4
   крок 2 - зправа маємо тип даних number зі значенням 3
   крок 3 - відбувається дія віднімання між number зі значенням 4 та number зі значенням 1 -> результат number зі значенням 1  */

'6' + 3 ** 0;
/* результат '61'
   крок 1 - оперерація зведення до ступені має пріоритет перед операцією додавання, тому спочатку зводиться numbr зі значенням 3 у ступінь 0 ->  результат number зі значенням 1
   крок 2 - зліва маємо тип даних string зі значенням '6'
   крок 3 - дія додавання склеює string зі значенням '6' та number зі значенням 1 -> отримали string зі значенням '61'  */

12 / '6'
/* результат 2
   крок 1 - зліва маємо тип даних number зі значенням 12
   крок 2 - зправа маємо типа даних string зі значенням '6',враховуючи арифметичний вираз з типом даних number -> відбувається неявне перетворення у типом даних number зі значенням 6
   крок 3 - відбувається арифметична дія поділ між number зі значенням 12 та number зі значенням 6 -> результат number зі значенням 2  */

'10' + (5 === 6);
/* результат '10false'
   крок 1 - дія у дужках має пріоритет над арифметичною дією додавання, тому перше відбуваєтся строге порівняння 2х однакових типів даних number зі значеннями 5 та 6 -> результат false
   крок 2 - зліва маємо типа даних string зі значенням '10'
   крок 3 - відбувається склуювання між типом даних string зі значенням '10' та типом даних boolean зі значенням false -> результат тип даних string зі значенням '10false' */

null == ''
/* результат false
   крок 1 - зліва маємо тип даних null
   крок 2 - зправа маємо пусту строку, яка має тип даних string
   крок 3 - при виконанні порівняння тип даних null ні до чого не приводиться і може дорівнювати лише undefined, в інших випадках повертається false */

3 ** (9 / 3);
/* результат 27
   крок 1 - дія у дужках має пріоритет, тому виконується першою -> відбувається поділ між двома однаковими типами даних number зі значеннями 9 та 3, результат поділу 3
   крок 2 - зліва маємо тип даних number зі значенням 3
   крок 3 - зводиться 3 у ступінь 3 -> результат 27 */

!!'false' == !!'true'
/* результат true
   крок 1 - зліва та зправа маємо 2 логічні оператори НІ, кожен з яких змінює на протилежне (інвертує) значення boolean (повертає істене boolean значення виразу) ->
         -> конвертує значення виразу у тип даних boolean
   крок 2 - зліва маємо тип даних string зі значенням 'false', який явно конвертується у тип даних boolean зі значенням true
   крок 3 - зправа маємо тип даних string зі значенням 'true', який явно конвертується у тип даних boolean зі значенням true 
   крок 4 - оператор рівності порівнює між собою два boolean типа даних з однаковими значеннями true -> отримали тип даних boolean зі значенням true */

0 || '0' && 1
/* результат 1
   крок 1 - логічний оператор І має пріоритет над логічним оператором АБО, таким чином вираз можна представити як 0 || ('0' && 1)
   крок 2 - зправа логічний оператор І обчислює тип даних string зі значенням '0' та тип даних number зі значенням 1 -> обидва ці значення повертають true, 
            а значить оператор повертає останньє true -> number зі значенням 1
   крок 3 - зліва маємо тип даних number зі значенням 0, яке повертає false
   крок 4 - при виконанні логічний оператор АБО повертає перший операнд який має значення true -> в даному випадку це другий операнд з типом даних number та значенням 1  */

(+null == false) < 1;
/* результат false
   крок 1 - у дужках: зліва маємо явне перетворення null до типу даних number зі значенням 0
   крок 2 - у дужках: зправа маємо тип даних boolean зі значенням  false, яке неявно перетворюється на number зі значенням 0
   крок 3 - у дужках: відбувається порівняння цих 2х значень і повертається результат boolean зі значенням true
   крок 4 - тип даних boolean зі значенням true за допомогою оператора рівності порівнюється з типом даних number зі значенням 0
            при цьому тип даних boolean зі значенням true неявно перетворюється на  number зі значенням 1
   крок 5 - т.к. 1 не може бути меншим за 1 -> отрималт результат за типом даних boolean зі значенням  false  */

false && true || true
/* результат true
   крок 1 - логічний оператор І має пріоритет над логічним оператором АБО, таким чином вираз можна представити як (false && true) || true
   крок 2 - зліва логічний оператор І обчислює тип даних boolean зі значеннями false та true
            якщо у виразі є false, оператор І порертає перше false -> отже отримали тип даних boolean зі значенням  false
   крок 3 - зправа маємо тип даних boolean зі значенням true
   крок 4 - при виконанні логічний оператор АБО повертає перший операнд який має значення true -> в даному випадку це другий операнд   */

false && (false || true);
/* результат false
   крок 1 - вираз у дужках має пріоритет над логічним оператором І
   крок 2 - у дужках маємо два операнди з типом даних boolean зі значеннями false та true та логічний оператор АБО, який повертає перше true -> 
            -> це є тип даних boolean зі значеннями true
   крок 3 - зліва маємо тип даних boolean зі значенням false
   крок 4 - при виконанні логічний оператор І повертає перше false -> отже повернувся тип даних boolean зі значенням false (перший операнд)   */

(+null == false) < 1 ** 5;
/* результат false
   крок 1 - у дужках: зліва маємо явне перетворення null до типу даних number зі значенням 0
   крок 2 - у дужках: зправа маємо тип даних boolean зі значенням  false, яке неявно перетворюється на number зі значенням 0
   крок 3 - у дужках: відбувається порівняння цих 2х значень і повертається результат boolean зі значенням true
   крок 4 - зправа відбувається зведення у ступінь -> результат тип даних number зі значенням 1
   крок 5 - тип даних boolean зі значенням true за допомогою оператора МЕНШЕ порівнюється з типом даних number зі значенням 1
            при цьому тип даних boolean зі значенням true неявно перетворюється на  number зі значенням 1
   крок 6 - т.к. 1 не може бути меншим за 1 -> отрималт результат за типом даних boolean зі значенням  false  */
